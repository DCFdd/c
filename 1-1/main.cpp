#include <iostream>

using namespace std;
#pragma execution_character_set("utf-8");


//类名：student ，类成员char neme[64];  char age;，类就是一个大型结构体
// 定义了一个学生类
class student
{
public://公有权限
    char name[64];  // 学生姓名
    char age;       // 学生年龄
};// 定义了一个学生类



//构造函数：
//构造函数是面向对象编程中用于对象初始化的特殊函数。它在创建对象时自动触发，用于初始化对象的成员变量和执行必要的初始化操作。
//构造函数的函数名与类名相同，没有返回类型。构造函数可以接受参数，用于初始化对象的成员变量。构造函数可以是公有的、私有的或受保护的，取决于需要。




//析构函数：
//析构函数是面向对象编程中用于对象清理和资源释放的特殊函数。它在对象被销毁时自动触发，用于执行对象的清理和资源释放操作。
//析构函数的函数名与类名相同，在函数名前面加上了波浪线（~），没有返回类型。析构函数不接受任何参数。通常情况下，析构函数是公有的，因为需要在对象销毁时被调用。

//类名：stringa ，类成员整形的a，类就是一个大型结构体
//类里面也可以定义函数
class stringa//class定义一个类，类名为stringa
{


    public:                                                                         //公有权限：
                                                                                    //公有成员可以在类的内部、外部和派生类中访问。
                                                                                    //其他类的对象可以访问公有成员。
                                                                                    //使用 public: 关键字来声明公有成员。
        int a ;
        void tser1()//可以直接在类中定义函数，
        {
            cout<<"123"<<endl;
        }
        void tset2();//也可以写在类的外面

        void test3();//类函数的重载定义，可以定义两个相同名字的函数，但是传参不一样
        void tset3(int a );//同上。
                           //调用谁：根据调用的时候，传参类型，自动匹配函数



        //构造函数：必须在类里面定义，可以在类里面，也可以在类里面定义，函数在外部写
        //构造函数是面向对象编程中用于对象初始化的特殊函数。它在创建对象时自动触发，用于初始化对象的成员变量和执行必要的初始化操作。
        //构造函数的函数名与类名相同，没有返回类型。构造函数可以接受参数，用于初始化对象的成员变量。构造函数可以是公有的、私有的或受保护的，取决于需要。
        stringa();//构造函数，名和类名要一样


        //析构函数：必须在类里面定义，可以在类里面，也可以在类里面定义，函数在外部写
        //析构函数是面向对象编程中用于对象清理和资源释放的特殊函数。它在对象被销毁时自动触发，用于执行对象的清理和资源释放操作。
        //析构函数的函数名与类名相同，在函数名前面加上了波浪线（~），没有返回类型。析构函数不接受任何参数。通常情况下，析构函数是公有的，因为需要在对象销毁时被调用。
        ~stringa();//构造函数，名和类名要一样，前面要加~



    private:                                                                        //私有权限：
                                                                                    //私有成员只能在类的内部访问，外部和派生类无法直接访问。
                                                                                    //只有类的成员函数可以访问私有成员。
                                                                                    //默认情况下，类的成员是私有的。
                                                                                    //使用 private: 关键字来声明私有成员。
                                                                                    //只能在自己的类里面访问自己
      //  int haha;



    protected:
                                                                                    // 受保护权限：
                                                                                    // 受保护成员可以在类的内部和派生类中访问，但不能在类的外部直接访问。
                                                                                    // 只有类的成员函数和派生类的成员函数可以访问受保护成员。
                                                                                    // 使用 protected: 关键字来声明受保护成员。
                                                                                    // 可以在自己的类里面访问自己，也可以在派生类中访问自己。

};

//继承类的定义，以下只有格式，内容可以自己翻找
//相当于在原类里面多添加需要的类，通过.和->来直接访问父类的成员
//私有不能被继承
class mystringa:public stringa
{

public:


};




stringa::stringa()//构造函数的函数体/////////////////构造函数可以重载
{
    //如果初始化这个类了，就会第一时间的进行该构造函数的执行
    cout<<"1"<<endl;
    cout<<"结构体开始"<<endl;

}

stringa::~stringa()//析构函数的函数体，外部定义的函数体
{
    cout<<"2"<<endl;

    cout<<"结构体结束"<<endl;
}

void stringa::tset2()//类里面的函数，在外部定义的办法
{
    //haha = 15;//私有变量可以通过类内部的函数绕开类，进行输出
    cout<<"456"<<endl;

}


int main()
{
    student my;//student 是类   my是对象
    // stringa* ms = new stringa(); 创建了一个 stringa 类型的动态对象，并将其地址存储在指针变量 ms 中。这意味着对象是在堆上分配的，其生命周期不受限于其所在的作用域。
    //通过指针 ms，可以访问和操作对象的成员变量和成员函数。需要注意的是，在使用完对象后，应该使用 delete 运算符手动释放内存。
    // student my; 创建了一个 student 类型的对象，这是在栈上分配内存的默认方式。对象的生命周期受限于其所在的作用域。通过对象名 my，可以访问和操作对象的成员变量和成员函数。
    //当对象 my 超出其作用域时，内存会自动释放。
    stringa* ms = new stringa();//
    ms->a = 10;//类的使用
    cout<<ms->a<<endl;//使用
    ms->tser1();//类内部函数的调用
    ms->tset2();//类外部函数的调用
    //ms.haha = 10;//私有变量，无法访问
    delete ms;//结束ms类，激活析构函数
    cout << "Hello World!" << endl;
    return 0;
}
